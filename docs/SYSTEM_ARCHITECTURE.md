# üèóÔ∏è Architecture Syst√®me - Hedera Health ID

## üìã Vue d'ensemble

Hedera Health ID est une plateforme de gestion d'identit√© m√©dicale d√©centralis√©e qui combine les technologies web modernes avec la blockchain Hedera Hashgraph pour cr√©er un √©cosyst√®me de sant√© s√©curis√© et interop√©rable.

## üéØ Objectifs Architecturaux

### Principes de conception
- **S√©curit√© par d√©faut** : Chiffrement et authentification robustes
- **Scalabilit√©** : Architecture modulaire et microservices
- **Interop√©rabilit√©** : Standards ouverts et APIs RESTful
- **D√©centralisation** : Int√©gration blockchain pour la confiance
- **Performance** : Optimisation des requ√™tes et mise en cache

## üèõÔ∏è Architecture Globale

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Frontend      ‚îÇ    ‚îÇ   Backend       ‚îÇ    ‚îÇ   Blockchain    ‚îÇ
‚îÇ   React + TS    ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   Node.js + TS  ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   Hedera HCS    ‚îÇ
‚îÇ   Tailwind CSS  ‚îÇ    ‚îÇ   Express       ‚îÇ    ‚îÇ   Smart Contracts‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚ñº                       ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PWA Service   ‚îÇ    ‚îÇ   PostgreSQL    ‚îÇ    ‚îÇ   IPFS Storage  ‚îÇ
‚îÇ   Worker        ‚îÇ    ‚îÇ   Prisma ORM    ‚îÇ    ‚îÇ   (Future)      ‚îÇ
‚îÇ   Offline Cache ‚îÇ    ‚îÇ   Neon Cloud    ‚îÇ    ‚îÇ   Distributed   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üîß Couche Frontend

### Technologies utilis√©es
- **React 18** : Framework UI avec hooks modernes
- **TypeScript** : Typage statique pour la robustesse
- **Vite** : Build tool rapide et moderne
- **Tailwind CSS** : Framework CSS utility-first
- **React Router** : Navigation c√¥t√© client
- **PWA** : Progressive Web App avec service worker

### Structure des composants

```
src/
‚îú‚îÄ‚îÄ components/           # Composants r√©utilisables
‚îÇ   ‚îú‚îÄ‚îÄ ui/              # Composants UI de base
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Input.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Select.tsx
‚îÇ   ‚îú‚îÄ‚îÄ patient/         # Composants sp√©cifiques patients
‚îÇ   ‚îú‚îÄ‚îÄ medecin/         # Composants sp√©cifiques m√©decins
‚îÇ   ‚îî‚îÄ‚îÄ hospital/        # Composants sp√©cifiques h√¥pitaux
‚îú‚îÄ‚îÄ pages/               # Pages principales
‚îÇ   ‚îú‚îÄ‚îÄ PatientDashboard.tsx
‚îÇ   ‚îú‚îÄ‚îÄ MedecinDashboardModern.tsx
‚îÇ   ‚îî‚îÄ‚îÄ HospitalDashboard.tsx
‚îú‚îÄ‚îÄ services/            # Services et APIs
‚îÇ   ‚îú‚îÄ‚îÄ api.ts           # Client API REST
‚îÇ   ‚îî‚îÄ‚îÄ qrCodeService.ts # Gestion QR codes
‚îú‚îÄ‚îÄ utils/               # Utilitaires
‚îî‚îÄ‚îÄ hooks/               # Hooks personnalis√©s
```

### Patterns architecturaux
- **Component-Based Architecture** : Composants r√©utilisables et modulaires
- **Custom Hooks** : Logique m√©tier encapsul√©e
- **Context API** : Gestion d'√©tat globale
- **Error Boundaries** : Gestion d'erreurs robuste

## ‚öôÔ∏è Couche Backend

### Technologies utilis√©es
- **Node.js** : Runtime JavaScript serveur
- **Express.js** : Framework web minimaliste
- **TypeScript** : Typage statique c√¥t√© serveur
- **Prisma ORM** : Mapping objet-relationnel moderne
- **PostgreSQL** : Base de donn√©es relationnelle
- **bcrypt** : Hachage s√©curis√© des mots de passe

### Architecture API REST

```
/api/v1/
‚îú‚îÄ‚îÄ auth/                # Authentification
‚îÇ   ‚îú‚îÄ‚îÄ POST /patient    # Connexion patient
‚îÇ   ‚îú‚îÄ‚îÄ POST /medecin    # Connexion m√©decin
‚îÇ   ‚îî‚îÄ‚îÄ POST /hospital   # Connexion h√¥pital
‚îú‚îÄ‚îÄ patients/            # Gestion patients
‚îÇ   ‚îú‚îÄ‚îÄ GET /            # Liste patients
‚îÇ   ‚îú‚îÄ‚îÄ GET /:id         # D√©tail patient
‚îÇ   ‚îú‚îÄ‚îÄ POST /           # Cr√©er patient
‚îÇ   ‚îî‚îÄ‚îÄ GET /:id/consultations # Consultations
‚îú‚îÄ‚îÄ medecins/            # Gestion m√©decins
‚îú‚îÄ‚îÄ hopitaux/            # Gestion h√¥pitaux
‚îî‚îÄ‚îÄ consultations/       # Gestion consultations
```

### Patterns architecturaux
- **RESTful API** : Architecture orient√©e ressources
- **Middleware Pattern** : Traitement des requ√™tes en pipeline
- **Repository Pattern** : Abstraction de la couche donn√©es
- **Error Handling** : Gestion centralis√©e des erreurs

## üóÑÔ∏è Couche Donn√©es

### Mod√®le de donn√©es

```sql
-- Patients : Utilisateurs finaux
patients (
  id: UUID PRIMARY KEY,
  patientId: VARCHAR UNIQUE,  -- Format: BJ2025001
  nom, prenom, email, telephone,
  passwordHash: VARCHAR,      -- bcrypt hash
  hopitalPrincipal: VARCHAR,
  isActive: BOOLEAN,
  createdAt, updatedAt: TIMESTAMP
)

-- M√©decins : Professionnels de sant√©
medecins (
  id: UUID PRIMARY KEY,
  medecinId: VARCHAR UNIQUE,  -- Format: MED-CHU-001
  nom, prenom, email, telephone,
  specialite, service: VARCHAR,
  hopitalId: UUID REFERENCES hopitaux(id),
  isActive: BOOLEAN,
  createdAt, updatedAt: TIMESTAMP
)

-- H√¥pitaux : √âtablissements de sant√©
hopitaux (
  id: UUID PRIMARY KEY,
  code: VARCHAR UNIQUE,       -- Format: CHU-MEL
  nom, ville, adresse: VARCHAR,
  telephone, email: VARCHAR,
  directeur: VARCHAR,
  isActive: BOOLEAN,
  createdAt, updatedAt: TIMESTAMP
)

-- Administrateurs h√¥pital
hospital_admins (
  id: UUID PRIMARY KEY,
  adminId: VARCHAR UNIQUE,    -- Format: ADMIN-CHU-001
  nom, prenom, email: VARCHAR,
  passwordHash: VARCHAR,      -- bcrypt hash
  hopitalId: UUID REFERENCES hopitaux(id),
  role: VARCHAR,              -- admin, super_admin
  isActive: BOOLEAN,
  createdAt, updatedAt: TIMESTAMP
)

-- Consultations m√©dicales
consultations (
  id: UUID PRIMARY KEY,
  consultationId: VARCHAR UNIQUE, -- Format: CONS-2025-001
  patientId: UUID REFERENCES patients(id),
  medecinId: UUID REFERENCES medecins(id),
  hopitalId: UUID REFERENCES hopitaux(id),
  dateConsultation: TIMESTAMP,
  type, motif: VARCHAR,
  diagnostic, notes: TEXT,
  statut: VARCHAR,            -- PROGRAMMEE, EN_COURS, TERMINEE
  createdAt, updatedAt: TIMESTAMP
)
```

### Relations et contraintes

```sql
-- Index pour les performances
CREATE INDEX idx_patients_patientId ON patients(patientId);
CREATE INDEX idx_medecins_email ON medecins(email);
CREATE INDEX idx_consultations_patient ON consultations(patientId);
CREATE INDEX idx_consultations_medecin ON consultations(medecinId);

-- Contraintes d'int√©grit√©
ALTER TABLE consultations 
  ADD CONSTRAINT fk_consultation_patient 
  FOREIGN KEY (patientId) REFERENCES patients(id);

ALTER TABLE consultations 
  ADD CONSTRAINT fk_consultation_medecin 
  FOREIGN KEY (medecinId) REFERENCES medecins(id);
```

## üîê Couche S√©curit√©

### Authentification multi-niveaux

```typescript
// Hachage bcrypt avec 12 rounds
const saltRounds = 12;
const passwordHash = await bcrypt.hash(password, saltRounds);

// Validation des mots de passe
const isValid = await bcrypt.compare(password, storedHash);

// G√©n√©ration de tokens JWT (simul√©s)
const token = `${userType}_jwt_${userId}_${timestamp}`;
```

### Validation des donn√©es

```typescript
// Validation c√¥t√© serveur
const validatePatientId = (id: string): boolean => {
  return /^BJ\d{7}$/.test(id); // Format: BJ2025001
};

const validateEmail = (email: string): boolean => {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
};
```

### Protection CORS

```typescript
app.use(cors({
  origin: process.env.CORS_ORIGIN || 'http://localhost:3000',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
```

## üåê Couche Communication

### Protocoles de communication

```typescript
// Client API avec gestion d'erreurs
class ApiService {
  private baseUrl: string;
  
  async request<T>(endpoint: string, options: RequestInit): Promise<ApiResponse<T>> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      mode: 'cors',
      credentials: 'omit',
      ...options,
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return await response.json();
  }
}
```

### Format de r√©ponse standardis√©

```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
  count?: number;
}

// Exemple de r√©ponse
{
  "success": true,
  "data": {
    "token": "patient_jwt_...",
    "patient": { ... }
  },
  "message": "Authentification r√©ussie"
}
```

## üîó Int√©gration Blockchain (Hedera)

### Architecture d√©centralis√©e (Phase 2)

```typescript
// Hedera Consensus Service (HCS)
interface HederaService {
  // Cr√©ation d'un topic pour les dossiers m√©dicaux
  createMedicalRecordTopic(): Promise<TopicId>;
  
  // Soumission d'une transaction m√©dicale
  submitMedicalTransaction(
    topicId: TopicId, 
    encryptedData: string
  ): Promise<TransactionId>;
  
  // V√©rification de l'int√©grit√© des donn√©es
  verifyDataIntegrity(
    transactionId: TransactionId
  ): Promise<boolean>;
}
```

### Smart Contracts (Future)

```solidity
// Contrat de gestion des identit√©s m√©dicales
contract MedicalIdentity {
    struct Patient {
        string patientId;
        bytes32 dataHash;
        address authorizedDoctor;
        uint256 timestamp;
    }
    
    mapping(address => Patient) public patients;
    
    function registerPatient(
        string memory _patientId,
        bytes32 _dataHash
    ) public {
        patients[msg.sender] = Patient({
            patientId: _patientId,
            dataHash: _dataHash,
            authorizedDoctor: address(0),
            timestamp: block.timestamp
        });
    }
}
```

## üìä Monitoring et Observabilit√©

### M√©triques syst√®me

```typescript
// Health check endpoint
app.get('/health', async (req, res) => {
  const health = {
    status: 'OK',
    timestamp: new Date().toISOString(),
    database: await checkDatabaseConnection(),
    version: process.env.npm_package_version,
    uptime: process.uptime(),
    memory: process.memoryUsage()
  };
  
  res.json(health);
});
```

### Logging structur√©

```typescript
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'app.log' })
  ]
});
```

## üöÄ D√©ploiement et Scalabilit√©

### Architecture de d√©ploiement

```yaml
# Docker Compose pour d√©veloppement
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - VITE_API_BASE_URL=http://backend:3001
      
  backend:
    build: ./backend
    ports:
      - "3001:3001"
    environment:
      - DATABASE_URL=${DATABASE_URL}
    depends_on:
      - database
      
  database:
    image: postgres:15
    environment:
      - POSTGRES_DB=hedera_health
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
```

### Strat√©gies de scalabilit√©

1. **Horizontal Scaling** : Load balancers et instances multiples
2. **Database Sharding** : Partitionnement par r√©gion/h√¥pital
3. **Caching** : Redis pour les sessions et donn√©es fr√©quentes
4. **CDN** : Distribution des assets statiques
5. **Microservices** : S√©paration par domaine m√©tier

## üîÆ √âvolution Future

### Roadmap technique

**Phase 1 (Actuelle) :**
- ‚úÖ Architecture web classique
- ‚úÖ Base de donn√©es centralis√©e
- ‚úÖ Authentification s√©curis√©e

**Phase 2 (Q1 2025) :**
- üîÑ Int√©gration Hedera HCS
- üîÑ Stockage d√©centralis√© (IPFS)
- üîÑ Smart contracts basiques

**Phase 3 (Q2-Q3 2025) :**
- üìã Interop√©rabilit√© HL7 FHIR
- üìã IA pour l'analyse m√©dicale
- üìã T√©l√©m√©decine int√©gr√©e

**Phase 4 (Q4 2025) :**
- üìã √âcosyst√®me complet
- üìã Marketplace de services
- üìã Gouvernance d√©centralis√©e

---

**üèóÔ∏è Architecture robuste et √©volutive pour l'avenir de la sant√© num√©rique**
